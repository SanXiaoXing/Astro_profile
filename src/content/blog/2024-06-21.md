---
title: 慢刷Leetcode算法题
pubDate: 2024-06-21 22:05
description: "每日刷力扣"
catalog: true
categories:
  - Leetcode
tags:
  - Leetcode
mathjax: true
inv-tags: blog
pin: true 
---

# 2024-06-21

## [LCP 61. 气温变化趋势](https://leetcode.cn/problems/6CE719/)

### Ideas

 - **计算气温变化趋势**：对于每个地区，计算每一天与下一天的气温变化趋势。我们可以用一个数组来存储这些变化趋势。

- **比较两个地区的气温变化趋势**：遍历两个变化趋势数组，找到连续相同的最大天数。

```java title="java"
public class Solution {

    /**
     * 计算两个地区气温变化趋势相同的最大连续天数
     *
     * @param temperatureA 地区A的气温数组
     * @param temperatureB 地区B的气温数组
     * @return 两地气温变化趋势相同的最大连续天数
     */
    public int temperatureTrend(int[] temperatureA, int[] temperatureB) {
        int maxLength = 0;     // 最大连续天数
        int currentLength = 0; // 当前连续天数

        // 遍历两个温度数组
        for (int i = 0; i < temperatureA.length - 1; i++) {
            // 计算第i天和第i+1天之间的气温变化趋势
            int trendA = getTrends(temperatureA[i], temperatureA[i + 1]);
            int trendB = getTrends(temperatureB[i], temperatureB[i + 1]);

            // 如果两个地区的气温变化趋势相同
            if (trendA == trendB) {
                currentLength++; // 当前连续天数加1
                maxLength = Math.max(maxLength, currentLength); // 更新最大连续天数
            } else {
                currentLength = 0; // 重置当前连续天数
            }
        }

        return maxLength; // 返回最大连续天数
    }

    /**
     * 计算两个温度之间的变化趋势
     *
     * @param A 第一天的气温
     * @param B 第二天的气温
     * @return 变化趋势：0表示平稳，-1表示下降，1表示上升
     */
    private int getTrends(int A, int B) {
        if (A == B) {
            return 0; // 平稳趋势
        }
        return A < B ? -1 : 1; // 上升趋势或下降趋势
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] temperatureA = {21, 18, 18, 18, 31}; // 地区A的气温数组
        int[] temperatureB = {34, 32, 16, 16, 17}; // 地区B的气温数组

        // 输出两地气温变化趋势相同的最大连续天数
        System.out.println(solution.temperatureTrend(temperatureA, temperatureB));  // 输出：2
    }
}
```

![result](https://cdn.jsdelivr.net/gh/SanXiaoXing/Image@main/blog/SanXiaoXing_2024-06-21.png)

# 思考

> 随着不断深入学习，发现算法才是代码的唯一解，或者说是他的最优解。从而我开始逐步的进行力扣的刷题之路。

随着公司压力的逐渐增大，我所承担的任务在难度和复杂度上都明显高于同组其他任务。然而，我并未获得应有的`激励`和`奖励`，这让我开始思考这份工作的付出与收益是否值得，于是我开始有了以快速提升自己从而得到更高的回报的内容。

